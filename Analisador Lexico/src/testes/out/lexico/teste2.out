const palavra_reservada 1:1
{ delimitador 1:7
int palavra_reservada 2:1
a id 2:5
= operador 2:7
2 numero 2:8
; delimitador 2:9
char palavra_reservada 3:1
b id 3:6
= operador 3:8
'a' caractere_constante 3:9
; delimitador 3:12
char palavra_reservada 4:1
a id 4:6
= operador 4:7
5 numero 4:8
; delimitador 4:9
int palavra_reservada 5:1
abcd id 5:5
= operador 5:9
0 numero 5:10
; delimitador 5:11
} delimitador 6:1
const palavra_reservada 7:1
{ delimitador 7:6
int palavra_reservada 8:1
a id 8:5
= operador 8:6
2 numero 8:7
; delimitador 8:8
} delimitador 9:1
int palavra_reservada 11:1
b id 11:5
; delimitador 11:6
int palavra_reservada 12:1
c id 12:5
; delimitador 12:6
char palavra_reservada 13:1
d id 13:6
; delimitador 13:7
float palavra_reservada 14:1
e id 14:7
; delimitador 14:8
string palavra_reservada 15:1
a1 id 15:8
; delimitador 15:10
class palavra_reservada 16:1
abb id 16:7
> operador 16:11
a1 id 16:13
{ delimitador 16:15
} delimitador 18:1
class palavra_reservada 19:1
dad id 19:7
{ delimitador 19:10
int palavra_reservada 20:1
ddd id 20:5
; delimitador 20:8
const palavra_reservada 21:1
{ delimitador 21:7
int palavra_reservada 22:1
a id 22:5
= operador 22:7
2 numero 22:8
; delimitador 22:9
char palavra_reservada 23:1
b id 23:6
= operador 23:8
'a' caractere_constante 23:9
; delimitador 23:12
char palavra_reservada 24:1
a id 24:6
= operador 24:7
5 numero 24:8
; delimitador 24:9
} delimitador 25:1
int palavra_reservada 27:2
abcd id 27:6
; delimitador 27:10
} delimitador 28:1
class palavra_reservada 30:1
son id 30:7
> operador 30:11
dad id 30:13
{ delimitador 30:16
} delimitador 32:1
class palavra_reservada 33:1
aaa id 33:7
> operador 33:11
aaa id 33:13
{ delimitador 33:16
} delimitador 35:1
class palavra_reservada 36:1
aaaa id 36:7
> operador 36:12
aba id 36:14
{ delimitador 36:17
} delimitador 38:1
class palavra_reservada 39:1
a id 39:7
{ delimitador 39:8
} delimitador 41:1
class palavra_reservada 42:1
aaa id 42:7
{ delimitador 42:11
const palavra_reservada 43:1
{ delimitador 43:7
int palavra_reservada 44:1
a id 44:5
= operador 44:6
10.10 numero 44:7
; delimitador 44:12
} delimitador 45:1
int palavra_reservada 46:1
a id 46:5
; delimitador 46:6
int palavra_reservada 47:1
b id 47:5
; delimitador 47:6
} delimitador 49:1
void palavra_reservada 53:1
main palavra_reservada 53:6
( delimitador 53:10
) delimitador 53:11
{ delimitador 53:13
int palavra_reservada 54:1
a id 54:5
; delimitador 54:6
float palavra_reservada 55:1
a id 55:7
; delimitador 55:8
if palavra_reservada 56:1
( delimitador 56:3
a id 56:4
== operador 56:5
2 numero 56:7
+ operador 56:8
2 numero 56:9
+ operador 56:10
2 numero 56:11
* operador 56:12
2 numero 56:13
&& operador 56:14
true palavra_reservada 56:16
) delimitador 56:20
{ delimitador 56:21
a id 57:1
= operador 57:3
10 numero 57:4
; delimitador 57:6
} delimitador 58:1
else palavra_reservada 58:3
{ delimitador 58:8
a id 59:1
= operador 59:2
2 numero 59:3
; delimitador 59:4
} delimitador 60:1
} delimitador 61:1
class palavra_reservada 64:1
capim id 64:7
> operador 64:13
folha id 64:15
{ delimitador 64:21
float palavra_reservada 65:5
isGreen id 65:11
( delimitador 65:18
int palavra_reservada 65:19
a id 65:23
, delimitador 65:24
int palavra_reservada 65:26
bbbb id 65:30
) delimitador 65:34
{ delimitador 65:36
int palavra_reservada 66:9
abcd id 66:13
; delimitador 66:17
return palavra_reservada 67:9
b id 67:16
; delimitador 67:17
} delimitador 68:5
} delimitador 70:1

nao ha erros lexicos
